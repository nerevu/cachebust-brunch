// Generated by CoffeeScript 2.4.1
(function() {
  var Cachebust, crypto, debug, fs, pathlib;

  fs = require('fs');

  crypto = require('crypto');

  pathlib = require('path');

  debug = require('debug')('brunch:cachebust');

  module.exports = Cachebust = (function() {
    class Cachebust {
      constructor(config) {
        var ref, ref1, ref2, ref3, ref4;
        this.onCompile = this.onCompile.bind(this);
        this._calculateHash = this._calculateHash.bind(this);
        this._hash = this._hash.bind(this);
        this.replaceContent = this.replaceContent.bind(this);
        this.config = config;
        this.options = Object.assign({
          enabled: true
        }, ((ref = this.config) != null ? (ref1 = ref.plugins) != null ? ref1.cachebust : void 0 : void 0) || {});
        this.publicFolder = ((ref2 = this.config) != null ? (ref3 = ref2.paths) != null ? ref3.public : void 0 : void 0) || 'public';
        this.targets = ((ref4 = this.options) != null ? ref4.extensions : void 0) || [/\.css$/, /\.js$/];
      }

      onCompile(files, assets) {
        var hashedFiles, manifest;
        hashedFiles = {};
        if (this.config.optimize && this.options.enabled) {
          this.targets.forEach((target) => {
            return files.forEach((file) => {
              var hashedPath, inputPath, outputPath, path;
              path = file.path;
              if (path.match(target)) {
                hashedPath = this._hash(path);
                inputPath = pathlib.relative(this.publicFolder, path);
                outputPath = pathlib.relative(this.publicFolder, hashedPath);
                return hashedFiles[inputPath] = outputPath;
              }
            });
          });
          this.replaceContent(hashedFiles);
        }
        manifest = this.options.manifest || pathlib.join(this.publicFolder, 'manifest.json');
        return fs.writeFileSync(manifest, JSON.stringify(hashedFiles, null, 4));
      }

      _calculateHash(file) {
        var precision, shasum;
        shasum = crypto.createHash('sha1');
        shasum.update(fs.readFileSync(file));
        precision = this.options.precision || 8;
        return shasum.digest('hex').slice(0, precision);
      }

      _hash(path) {
        var base, dir, ext, hash, outputFile, outputPath;
        dir = pathlib.dirname(path);
        ext = pathlib.extname(path);
        base = pathlib.basename(path, ext);
        hash = this._calculateHash(path);
        outputFile = `${base}-${hash}${ext}`;
        outputPath = pathlib.join(dir, outputFile);
        fs.renameSync(path, outputPath);
        return outputPath;
      }

      replaceContent(hashedFiles) {
        var content, refFile, reference;
        reference = this.options.reference || 'index.html';
        refFile = `${this.publicFolder}/${reference}`;
        content = fs.readFileSync(refFile, 'UTF-8');
        Object.entries(hashedFiles).forEach(([inputPath, outputPath]) => {
          var regExp;
          regExp = new RegExp(inputPath);
          if (regExp.test(content)) {
            content = content.replace(regExp, outputPath);
            return debug(`Replaced ${inputPath} by ${outputPath} in ${refFile}`);
          }
        });
        return fs.writeFileSync(refFile, content);
      }

    };

    Cachebust.prototype.brunchPlugin = true;

    return Cachebust;

  }).call(this);

}).call(this);
